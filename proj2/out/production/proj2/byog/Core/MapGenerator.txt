package byog.Core;

import byog.TileEngine.TERenderer;
import byog.TileEngine.TETile;
import byog.TileEngine.Tileset;
import org.junit.Test;
import javax.sql.rowset.serial.SQLOutputImpl;
import java.awt.*;
import java.util.IllegalFormatWidthException;
import java.util.LinkedList;
import java.util.Random;

/** This class generates a world to verify the random algorithm. */
public class MapGenerator {
    private static Random RANDOM;
    private static int WIDTH;
    private static int HEIGHT;
    private static final int BLOCK_WIDTH = 10;
    private static final int BLOCK_HEIGHT = 10;

    // block that have a room in it
    private LinkedList<Point> blockWithARoomList;

    public MapGenerator() {
    }

    public MapGenerator(long s) {
        RANDOM = new Random(s);
    }

    public TETile[][] generateMap(int width, int height) {
        //Initialize the world.
        WIDTH = width;
        HEIGHT = height;
        TETile[][] world = new TETile[width][height];
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                world[i][j] = Tileset.GRASS;
            }
        }

        //Compute all block position.
        blockList = computeBlockPoint(world);
        //Draw all block.
        for (Block block: blockList) {
            drawBlock(world, block);
        }

        //Remove the public walls and individual walls.
        removePublicWall(world);
        removeIndividualWall(world);

        //Render the world.(temp for debug
        TERenderer ter = new TERenderer();
        ter.initialize(width, height);
        ter.renderFrame(world);

        return world;
    }

    /**
     * According to the WIDTH and HEIGHT of the world, compute every block point.
     * @param world the world been given.
     * @return      return a linked list contains all points.
     */
    private LinkedList<Block> computeBlockPoint(TETile[][] world) {
        LinkedList<Block> blocks = new LinkedList<>();
        int pieceNumX = WIDTH / Block.BLOCK_LENGTH;
        int pieceNumY = HEIGHT / Block.BLOCK_LENGTH;
        for (int i = 0; i < pieceNumX; i++) {
            for (int j = 0; j < pieceNumY; j++) {
                Point pos = new Point(i * Block.BLOCK_LENGTH, j * Block.BLOCK_LENGTH);
                blocks.add(new Block(pos, null));
                world[i * Block.BLOCK_LENGTH][j * Block.BLOCK_LENGTH] = Tileset.TREE;
            }
        }
        return blocks;
    }

    /**
     * Draw a unit block in the given world.
     * @param world the world need drawn in.
     */
    private void drawBlock(TETile[][] world, Block block) {
        //Draw room in the block.
        drawRoomInBlock(world, block);

        //Draw hallway in the block.
        drawHallWayInBlock(world, block);
    }

    /**
     * Draw a room in current block.
     * @param world the world drawn in.
     * @param point the base point of the block.
     */
    private void drawRoomInBlock(TETile[][] world, Point point) {
        //draw a room in this block with probability 0.7
        if (RandomUtils.bernoulli(RANDOM, 0.95)) {
            blockWithARoom.add(point);
            int posX;
            int posY;
            //0.7 chance room base point locate in left down corner
            if (RandomUtils.bernoulli(RANDOM, 0.7)) {
                posX = point.x + RandomUtils.uniform(RANDOM, BLOCK_WIDTH / 2);
                posY = point.y + RandomUtils.uniform(RANDOM, BLOCK_HEIGHT / 2);
            } else {
                posX = point.x + RandomUtils.uniform(RANDOM, BLOCK_WIDTH);
                posY = point.y + RandomUtils.uniform(RANDOM, BLOCK_HEIGHT);
            }
            // get random width and height
            int width = RandomUtils.uniform(RANDOM, Room.ROOM_MIN_WIDTH, Room.ROOM_MAX_WIDTH);
            int height = RandomUtils.uniform(RANDOM, Room.ROOM_MIN_HEIGHT, Room.ROOM_MAX_HEIGHT);
            // draw room in base point position.
            drawRoom(world, new Room(new Point(posX, posY), width, height));
        }
    }

    /**
     * Draw a room.
     * @param world the world been given.
     * @param room  the room need to be drawn.
     */
    private void drawRoom(TETile[][] world, Room room) {
        int BottomLeftX = room.getPos().x;
        int BottomLeftY = room.getPos().y;
        int width = room.getWidth();
        int length = room.getLength();
        int topRightX = BottomLeftX + width;
        int topRightY = BottomLeftY + length;
        if (topRightX >= WIDTH || topRightY >= HEIGHT || BottomLeftX < 0 || BottomLeftY < 0) {
            return;
        }
        System.out.println(BottomLeftX + " " + BottomLeftY);
        for (int i = 0; i < room.getWidth(); ++i) {
            for (int j = 0; j < room.getLength(); ++j) {
                int posX = BottomLeftX + i;
                int posY = BottomLeftY + j;
                boolean roomEdge = (i == 0 || j == 0 || i == width - 1 || j == length - 1);
                // at edge should draw a wall
                if (roomEdge) {
                    world[posX][posY] = Tileset.WALL;
                } else {
                    world[posX][posY] = Tileset.FLOOR;
                }
            }
        }
    }

    /**
     * Draw at least one HallWay in the block with a room.
     * @param world the world need to draw in.
     * @param point base point of the block.
     */
    private void drawHallWayInBlock(TETile[][] world, Point point) {
        //  if there is a room in current block, draw at least one hallway
        if (blockWithARoom.contains(point)) {
            //choose a step
            int step = 0;
            if (RandomUtils.bernoulli(RANDOM, 0.5)) {
                step = 1;
            } else {
                step = -1;
            }
            Point basePoint = new Point(point.x + BLOCK_WIDTH / 2 - 1, point.y + BLOCK_HEIGHT / 2 - 1);
            Point guidePoint = new Point(point.x + BLOCK_WIDTH, point.y + BLOCK_HEIGHT / 2);

            for (int i = 0; i < 2; i++) {
                int posX = point.x + RandomUtils.uniform(RANDOM, BLOCK_WIDTH);
                int posY = point.y + RandomUtils.uniform(RANDOM, BLOCK_HEIGHT);
                int length = RandomUtils.uniform(RANDOM, Room.HALLWAY_MIN_LENGTH, Room.HALLWAY_MAX_LENGTH);
                int width = 0;
                int height = 0;
                if (RandomUtils.bernoulli(RANDOM, 0.5)) {
                    width = length;
                    height = 3;
                } else {
                    height = length;
                    width = 3;
                }
                drawRoom(world, new Room(new Point(posX, posY), width, height));
            }
        } else if (RandomUtils.bernoulli(RANDOM, 0.3)) {
            for (int i = 0; i < 3; i++) {
                int posX = point.x + RandomUtils.uniform(RANDOM, BLOCK_WIDTH);
                int posY = point.y + RandomUtils.uniform(RANDOM, BLOCK_HEIGHT);
                int length = RandomUtils.uniform(RANDOM, Room.HALLWAY_MIN_LENGTH, Room.HALLWAY_MAX_LENGTH);
                int width = 0;
                int height = 0;
                if (RandomUtils.bernoulli(RANDOM, 0.5)) {
                    width = length;
                    height = 3;
                } else {
                    height = length;
                    width = 3;
                }
                drawRoom(world, new Room(new Point(posX, posY), width, height));
            }
        }
        else {
            int posX = point.x + RandomUtils.uniform(RANDOM, BLOCK_WIDTH);
            int posY = point.y + RandomUtils.uniform(RANDOM, BLOCK_HEIGHT);
            int length = RandomUtils.uniform(RANDOM, Room.HALLWAY_MIN_LENGTH, Room.HALLWAY_MAX_LENGTH);
            int width = 0;
            int height = 0;
            if (RandomUtils.bernoulli(RANDOM, 0.5)) {
                width = length;
                height = 3;
            } else {
                height = length;
                width = 3;
            }
            drawRoom(world, new Room(new Point(posX, posY), width, height));
        }
    }
    
    private void drawHallWay(TETile[][] world, Point basePoint, String direction) {
        if (direction.equals("vertical")) {

        } else if (direction.equals("horizontal")) {
            
        } else {
            System.out.println("Illegal direction.");
        }
    }
    
    /**
     * Remove the walls shared by two rooms.
     * @param world the world need to be proceeded.
     */
    private void removePublicWall(TETile[][] world) {
        for (int i = 0; i < WIDTH; i++) {
            for (int j = 0; j < HEIGHT; j++) {
                boolean isMapEdge = (i == 0 || j == 0 || i == WIDTH - 1 || j == WIDTH - 1);
                if (!isMapEdge) {
                    boolean isWall = world[i][j].equals(Tileset.WALL);
                    boolean horizontalPublicWall = world[i][j - 1].equals(Tileset.FLOOR)
                            && world[i][j + 1].equals(Tileset.FLOOR);
                    boolean verticalPublicWall = world[i - 1][j].equals(Tileset.FLOOR)
                            && world[i + 1][j].equals(Tileset.FLOOR);
                    boolean publicWall = horizontalPublicWall || verticalPublicWall;
                    if (isWall && publicWall) {
                        world[i][j] = Tileset.FLOOR;
                    }
                }
            }
        }
    }

    /**
     * Remove the wall that has no wall around.
     * @param world the world need to be proceeded.
     */
    private void removeIndividualWall(TETile[][] world) {
        for (int i = 0; i < WIDTH; i++) {
            for (int j = 0; j < HEIGHT; j++) {
                boolean isMapEdge = (i == 0 || j == 0 || i == WIDTH - 1 || j == WIDTH - 1);
                if (!isMapEdge) {
                    boolean isWall = world[i][j].equals(Tileset.WALL);
                    boolean horizontalPublicWall = world[i][j - 1].equals(Tileset.FLOOR)
                            && world[i][j + 1].equals(Tileset.FLOOR);
                    boolean verticalPublicWall = world[i - 1][j].equals(Tileset.FLOOR)
                            && world[i + 1][j].equals(Tileset.FLOOR);
                    boolean individualWall = horizontalPublicWall && verticalPublicWall;
                    if (isWall && individualWall) {
                        world[i][j] = Tileset.FLOOR;
                    }
                }
            }
        }
    }

    private void connectTwoBlock(TETile[][] world)
}
